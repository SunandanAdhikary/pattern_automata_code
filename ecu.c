/**********************************************************************************************************************
 * \file GTM_TOM_Interrupt.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxPort.h"
#include "IfxGtm_Tom_Timer.h"
#include <stdio.h>
#include <stdlib.h>
#include "CanBasicDemo-v1.h"
#include <Cpu/Irq/IfxCpu_Irq.h>
#include "IfxCpu.h"
#include <Math.h>
#include "time.h"
#include "Bsp.h"
#include "Ifx_types.h"
//#include "UART_VCOM.c"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_TOM      3                       /* Interrupt priority number                                    */
#define ISR_PRIORITY_TOM1     2                       /* Interrupt1 priority number                                   */
#define ISR_PRIORITY_TOM2     1                       /* Interrupt2 priority number                                   */
#define TOM_FREQ              100.0f                  /* TOM frequency                                                */
#define TOM_FREQ_1            120.0f                  /* TOM frequency                                                */
#define LED1                  &MODULE_P20, 12         /* LED which will be toggled in Interrupt Service Routine (ISR) */
#define LED2                  &MODULE_P20, 13
#define IFX_INTTOS_CAN_TXRX   0
#define MAX_TICKS             20
#define WAIT_TIME             3
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxGtm_Tom_Timer g_timerDriver;                      /* TOM driver                                                   */
IfxGtm_Tom_Timer g_timerDriver1;                     /* TOM driver 1                                                 */
IfxGtm_Tom_Timer g_timerDriver2;                     /* TOM driver 2                                                 */
App_CanBasic g_CanBasic;
Ifx_TickTime g_tickFor3ms;
/*-------------------------------------------control/detection task-related variables--------------------------------------------------*/
///*esp Tx*/
//uint32 esp_tx_id = 451;//0x1A1;
//uint8 esp_tx_buf = 1;
//const unsigned int ESP_U1_offset = 200;
//const unsigned int ESP_U1_factor = 1000;//10;
//const int ct_esp = 4;                           // no. of instances in hyperperiod
//const int css_esp[4] = {1,1,1,1};
///*esp Rx*/
//uint32 esp_rx_id = 289;//0x121;
//const unsigned int ESP_XA_offset = 200;
//const unsigned int ESP_XA_factor = 100;//100;
//uint8 sensed_esp = 0;
//extern volatile __far int curIdx_esp = 0;
/*esp Tx*/
const uint32 esp_tx_id = 0xA1;
const uint8 esp_tx_buf = 1;
IfxCan_Message txEsp;
uint32 txDataEsp[2];
const unsigned int ESP_U1_offset = 200;
const unsigned int ESP_U1_factor = 1000;//10;
const int esp_h_ct = 4;
const int esp_h_set[4] = {10,20,40,80};
const int esp_states[4][2] = {{1,10},{1,-1},{1,-1},{1,-1}};
//const int esp_mdadt[4][1] = {{1},{1},{1},{1}};
const float esp_dev_thres = 0.1;
/*esp Rx*/
const uint32 esp_rx_id = 273;//0x111
const unsigned int ESP_XA_offset = 200;
const unsigned int ESP_XA_factor = 100;//100;
uint8 sensed_esp = 0;
extern volatile __far int curIdx_esp = 0;
/* esp states */
extern volatile __far float xhat_ESP[2] = {0,0};
extern volatile __far uint32 y1_ESP = 0;
extern volatile __far float u1_ESP = 0;

///*ttc Tx*/
//uint32 ttc_tx_id = 0xc4;
//uint8 ttc_tx_buf = 10;
//const unsigned int TTC_U1_offset = 200;
//const unsigned int TTC_U1_factor = 100;//10;
//const int ct_ttc = 4;                         // no. of instances in hyperperiod
//const int css_ttc[4] = {1,1,1,1};//{0,0,0,0};
////const int ct_ttc = 22;                         // no. of instances in hyperperiod
////const int css_ttc[22] = {1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1};//{0,0,0,0};
////const int css_ttc[22] = {1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0};//{0,0,0,0};
///*ttc Rx*/
//uint32 ttc_rx_id = 0x121;
//const unsigned int TTC_XA_offset = 200;//20;
//const unsigned int TTC_XA_factor = 100;
//const unsigned int TTC_XB_offset = 200;//20;
//const unsigned int TTC_XB_factor = 100;
//uint8 sensed_ttc = 0;
//extern volatile __far int curIdx_ttc = 0;
/*ttc Tx*/
const uint32 ttc_tx_id = 0xc4;
const uint8 ttc_tx_buf = 2;
IfxCan_Message txTtc;
uint32 txDataTtc[2];
const unsigned int TTC_U1_offset = 200;
const unsigned int TTC_U1_factor = 100;//10;
const int ttc_h_ct = 2;
const int ttc_h_set[2] = {50,100};
const int ttc_states[2][4] = {{1,10,100,1000},{1,10,-1,-1}};
const float ttc_dev_thres = 0.1;
/*ttc Rx*/
const uint32 ttc_rx_id = 289;//0x121;
const unsigned int TTC_XA_offset = 200;//20;
const unsigned int TTC_XA_factor = 100;
const unsigned int TTC_XB_offset = 200;//20;
const unsigned int TTC_XB_factor = 100;
uint8 sensed_ttc = 0;
extern volatile __far int curIdx_ttc = 0;
/* ttc states */
extern volatile __far float xhat_TTC[2] = {0,0};
extern volatile __far uint32 y1_TTC = 0;
extern volatile __far float u1_TTC = 0;

/*CC Tx*/
const uint32 cc_tx_id = 0xd1;//0x1a1;
const uint8 cc_tx_buf = 3;
IfxCan_Message txCc;
uint32 txDataCc[2];
const unsigned int CC_U1_offset = 200;
const unsigned int CC_U1_factor = 1000;//10;
const int cc_h_ct = 2;
const int cc_h_set[2] = {10, 20};
const int cc_states[2][2] = {{1,10},{1,10}};
const float cc_dev_thres = 0.5;
/*CC Rx*/
const uint32 cc_rx_id = 305;//0x131
const unsigned int CC_XA_offset = 200;
const unsigned int CC_XA_factor = 100;//100;
uint8 sensed_cc = 0;
extern volatile __far int curIdx_cc = 0;
/* ttc states */
extern volatile __far float xhat_CC[3] = {0,0,0};
extern volatile __far uint32 y1_CC = 0;
extern volatile __far float u1_CC = 0;

/*SC Tx*/
const uint32 sc_tx_id = 0xf4;//0x1b1;
const uint8 sc_tx_buf = 4;
IfxCan_Message txSc;
uint32 txDataSc[2];
const unsigned int SC_U1_offset = 200;
const unsigned int SC_U1_factor = 1000;//10;
const int sc_h_ct = 3;
const int sc_h_set[3] = {40, 80, 120};
const int sc_states[3][4] = {{11, 10, 100, 1000},{11, 10, 100, -1},{11, 10, -1, -1}};
const float sc_dev_thres = 0.1;
/*SC Rx*/
uint32 sc_rx_id = 321;//0x141
const unsigned int SC_XA_offset = 200;
const unsigned int SC_XA_factor = 100;//100;
uint8 sensed_sc = 0;
extern volatile __far int curIdx_sc = 0;
/* sc states */
extern volatile __far float xhat_SC[4] = {0,0,0,0};
extern volatile __far uint32 y1_SC  = 0;
extern volatile __far float u1_SC  = 0;


int ct_esp = 20;
int ct_ttc = 8;
int ct_cc = 20;
int ct_sc = 5;
int css_esp[20] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
int css_ttc[8] = {1,1,1,1,1,1,1,1};
int css_cc[20] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
int css_sc[5] = {1,1,1,1,1};

/* residue-based detector*/
uint32 dtc_tx_id = 0x04;
const unsigned int Th = 2;                     // threshold on residue
uint8 dtc_tx_buf = 2;

/* sba detector*/
uint32 sba_dtc_tx_id = 0x11;
const unsigned int Th_ct = 1;                  // threshold on sba attempt count
uint8 sba_dtc_tx_buf = 3;
volatile __far int sba_ct = 0;

extern volatile __far float xhatA_P4 = 0;
extern volatile __far float xhatB_P4 = 0;
extern volatile __far float xA_P4 = 0;
extern volatile __far float u1_P4 = 0;
extern volatile __far float xhatA_P5 = 0;
extern volatile __far float xhatB_P5 = 0;
extern volatile __far float xA_P5 = 0;
extern volatile __far float xB_P5 = 0;
extern volatile __far float u1_P5 = 0;// added 1

extern volatile float done = 0;


volatile __far unsigned int __align32 core_0_online=0;
volatile __far unsigned int __align32 core_1_online=0;


clock_t last;

uint32 g_tick = 0;   //Resolution is 0.1ms
uint32 g_tick_ms= 0;
uint32 g_clock= 0;


///*---------------------------------------------- taskset details----------------------------------------------------------*/
//uint8 task_ct = 3;
//uint8 task_ID[]= {200,300,400};
//uint8 task_per[]= {40,100,100};
////uint8 task_wcet[]= {2,40,100};
//uint8 task_wcet[]= {75,74,75};
//uint8 task_etct[] = {0,0,0};
//int i=0,j=0,k=0;
//uint8 sense[] = {0,0,0};
//uint32 wcet;

/*---------------------------------------------- taskset details:{esp,ttc,cc,sc}----------------------------------------------------------*/
uint8 task_ct = 4;
uint8 task_per[]= {1,0,1,1};    // current periodicity as index from tasks' h_sets (20,50,20,80)
//uint8 task_wcet[]= {2,40,100};
uint8 task_wcet[] = {5,4,5,7};
uint8 task_etct[] = {0,0,0,0};
int i=0, j=0, k=0, l=0;
uint8 sense[] = {0,0,0,0};
uint32 wcet;
uint32 HP = 400;


/*------ test -------*/
extern volatile int allinst = 0;
//extern volatile int inst = 0;
//extern vm msgs[500];
//extern uint32 traffic[2000];
/*********************/
extern volatile __far float xhatA_P1 = 0;
extern volatile __far float xhatB_P1 = 0;
extern volatile __far float xhatA_P2 = 0;
extern volatile __far float xhatB_P2 = 0;
extern volatile __far float xhatC_P2 = 0;

//extern volatile int core_1_online=0;

extern volatile __far float xA_P1 = 0;
extern volatile __far float u1_P1 = 0;
extern volatile __far float xA_P2 = 0;
extern volatile __far float u1_P2 = 0;

/*-----------------------------------------------------------------------------------------------------*/
/* EBCM */
void t120_tx();
void t100_tx();
void t50_tx();
void t40_tx();
void t80_tx();
void t20_tx();
void t10_tx();
/* ECM */
//void t1000_tx2();
//void t500_tx();
//void t250_tx();
//void t25_tx();
//void t12_5_tx();
/* others */
//void t1_esp(void);
//void t2_brakes(void);
//void t3_transmission(void);
//void t4_ttc(void);
//void t5_vc(void);
//void busload(int);
void residue_based_dtc(float a);
void sba_dtc(int);
int gcd(int, int);
int lcm(int, int);
int hp();

static volatile uint32 numTxmsgs[IFXCAN_NUM_MODULES];
static volatile uint32 numRxmsgs[IFXCAN_NUM_MODULES];
uint8 rxmsg_atkwinlen = 0;
uint32 *rxmsg_atkwin[] = {0};//(uint32 *)calloc(10,sizeof(uint32));
//rxmsg_atkwin = (uint32 *)calloc(1,sizeof(uint32));//&rxmsg_atkwin;

typedef enum
{
    IfxCan_dedicatedBuffers,
    IfxCan_fifo0,
    IfxCan_fifo1,
}IfxCan_MsgMode;

static void ProcessFifo0Interrupt(uint32 , IfxCan_MsgMode);

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/

IFX_INTERRUPT(Tx_Interrput1_ISR, IFX_INTTOS_CAN_TXRX, ISR_PRIORITY_CAN1_TX)
{
    Ifx_CAN   *canSfr = &MODULE_CAN1;
    if(CAN1_IR0.B.TC == 1)
    {
//        printf("transmitted\n");
        Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(canSfr,(IfxCan_NodeId)0);
        IfxCan_Node_clearInterruptFlag(nodeSfr,IfxCan_Interrupt_transmissionCompleted);
        numTxmsgs[1]++;
//        printf("Tx \n");
    }
}

IFX_INTERRUPT(Rx_Interrput0_ISR, IFX_INTTOS_CAN_TXRX, ISR_PRIORITY_CAN0_RX)// vectabnum=IFX_INTTOS_CAN_TXRX
{
    Ifx_CAN   *canSfr =  &MODULE_CAN0;
    if(CAN0_IR0.B.RF0N == 1)
    {
        Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(canSfr,(IfxCan_NodeId)0);
        IfxCan_Node_clearInterruptFlag(nodeSfr,IfxCan_Interrupt_rxFifo0NewMessage);
//        printf("int rx at %d\n",i);
        ProcessFifo0Interrupt (0 , IfxCan_fifo0);
        numRxmsgs[1]++;
    }
}

static void ProcessFifo0Interrupt (uint32 canNode , IfxCan_MsgMode rxMsgType)
{
    IfxCan_Message rxMsg;
    uint32 rxData[2];
    IfxCan_Can_initMessage(&rxMsg);

    rxData[0] = 0x00000000;
    rxData[1] = 0x00000000;

    rxMsg.readFromRxFifo1 = FALSE;
    rxMsg.readFromRxFifo0 = TRUE;
    IfxCan_Can_readMessage(&g_CanBasic.drivers.canNode[canNode], &rxMsg, rxData);
//    printf("rx %x at %d\n",rxMsg.messageId,i);
    /* test wcet hns */
    allinst++;
/*
//    vm msg;
//    traffic[allinst] = rxMsg.messageId;
//    allinst++;
//    if( traffic[allinst] == 0xA1 || traffic[allinst] == 0xB1 || traffic[allinst] == 0xC4){
//        msg.id = rxMsg.messageId;
//        msgs[inst] = msg;
//        inst ++ ;
//    }
*/
    /* for ttc */
    /*
    if (rxMsg.messageId < ttc_rx_id){
        rxmsg_atkwin[rxmsg_atkwinlen++] = rxMsg.messageId;
        *rxmsg_atkwin = (uint32*)realloc(rxmsg_atkwin,2*sizeof(uint32));
        for(int i = 0; i<=rxmsg_atkwinlen; i++)
            printf("ids in window of \n");
            //            printf("ids in window of %u:\t %u\n", ttc_rx_id, rxmsg_atkwin[i]);
    }else{
        rxmsg_atkwinlen = 0;
        free(rxmsg_atkwin);
        *rxmsg_atkwin = (uint32*)calloc(1,sizeof(uint32));
    }
    */
    if (rxMsg.messageId == ttc_rx_id)//0x130)//ttc_rx_id)
    {
       xA_P5= rxData[0];
       sense[2] = 1;
       sensed_ttc = 1;
       printf("rx ttc sensor data %x = %f  at %d\n",rxMsg.messageId,xA_P5,i);
//       clock_t start = clock();
//       CanBasicDemo_run2();
//       clock_t end = clock();
//       unsigned long dur = (end-start);
//       printf("wcet ttc: %ld s\n",dur);
    }
    //
    /* for esp */
    if (rxMsg.messageId == esp_rx_id)//0x121)//esp_rx_id)
    {
       xA_P4= rxData[0];
//       xB_P4= rxData[0];
       sense[0] = 1;
       sensed_esp =1;
       printf("rx esp sensor data id %x = %f at %d\n",rxMsg.messageId,xA_P4,i);
//       clock_t start = clock();
//       CanBasicDemo_run1();
//       clock_t end = clock();
//       unsigned long dur = (end-start);
//       printf("wcet esp: %ld s\n",dur);
    }
    /* for cc */
    if (rxMsg.messageId == cc_rx_id)
    {
       y1_CC= rxData[0];
//       xB_P4= rxData[0];
       sense[2] = 1;
       sensed_cc =1;
       printf("rx cc sensor data id %x = %u at %d\n",rxMsg.messageId,y1_CC,i);
//       clock_t start = clock();
//       CanBasicDemo_run1();
//       clock_t end = clock();
//       unsigned long dur = (end-start);
//       printf("wcet esp: %ld s\n",dur);
    }
    /* for sc */
    if (rxMsg.messageId == sc_rx_id)
    {
       y1_SC= rxData[0];
//       xB_P4= rxData[0];
       sense[3] = 1;
       sensed_sc =1;
       printf("rx sc sensor data id %x = %u at %d\n",rxMsg.messageId,y1_SC,i);
//       clock_t start = clock();
//       CanBasicDemo_run1();
//       clock_t end = clock();
//       unsigned long dur = (end-start);
//       printf("wcet esp: %ld s\n",dur);
    }


//    printf("sba_ct = %d at %d\n",sba_ct,i);
    /* for sba dtc */
    if (rxMsg.messageId == ttc_tx_id)
    {
        printf("rx ttc ctrl data id %x at %d\n",rxMsg.messageId,i);
        int skipped = css_ttc[(curIdx_ttc-1) % ct_ttc];
//        sba_dtc(skipped);
    }else if (rxMsg.messageId == esp_tx_id )
    {
        int skipped = css_esp[(curIdx_esp-1) % ct_esp];
//        sba_dtc(skipped);
    }else if (rxMsg.messageId == cc_tx_id )
    {
        printf("rx cc ctrl data id %x at %d\n",rxMsg.messageId,i);
//        ct_esp = HP / ttc_h_set[task_per[2]];
        int skipped = css_cc[(curIdx_cc-1) % ct_cc];
//        sba_dtc(skipped);
    }else if (rxMsg.messageId == sc_tx_id )
    {
        printf("rx sc ctrl data id %x at %d\n",rxMsg.messageId,i);
//        ct_esp = HP / ttc_h_set[task_per[3]];
        int skipped = css_sc[(curIdx_sc-1) % ct_sc];
//        sba_dtc(skipped);
    }
    /* test */
    /*
    uint32 id = 0xc4;
    if (rxMsg.messageId == id)
    {
        printf("rx id %x at %d\n",rxMsg.messageId,i);
    }
    */
}

/* transmission strategy for non-premtive schedule */
/*
void task_scheduler(uint32 a, int todo, int ex)
{
    if (a==100 && todo == 1)
    {
        t1_vc();
    }
    if (a==200 && todo == 1)
    {
        t2_brakes();
    }
    if (a==300 && todo == 1)
    {
         t3_transmission();
    }
    if (a==400)
    {
        if(todo == 0 && ex ==1){
            ex  = 0; // executing
//            CanBasicDemo_run2();
        }
        if(todo == 1)
         t4_ttc();
         ex = 1;
     }
    else if (a==-1)
    {
        idle_task();
    }
}

*/
/*
void task_scheduler(uint32 a)
{
    if (a==40)
    {
        t1_esp();
    }
    if (a==200)
    {
//        task_etct[0] = task_etct[0]+1;
//        if(task_etct[0] == task_wcet[0]){
        t2_brakes();
//                task_etct[0] = 0;
//        }
    }
    if (a==300)
    {
        task_etct[1] = task_etct[1]+1;
        if(task_etct[1] == task_wcet[1])
        {
            t3_transmission();
            task_etct[1] = 0;
        }
    }
    if (a==100)
    {
//        task_etct[2] = task_etct[2]+1;
//        printf("ex\n");
//        if(task_etct[2] == task_wcet[2]){
//            printf("tx\n");
//            t1_esp();
            t4_ttc();

//            task_etct[2] = 0;
//        }
     }
    if (a==-1)
    {
        idle_task();
    }

}

*/
//void t3_ttc() /* This is the code of TTC  */
//{
//    uint32 txData2[2];
//
//    float aAA = 1, aAB = 0.1;
//    float aBA = 0, aBB = 1.0;
//
//    float bA = 0.005;
//    float bB = 0.1;
//
//
//    float KAA = -0.9171, KAB = -1.6356;
//
//
//    float LAA = 0.8327;
//    float LBA = 2.5029;
//
//    float new_xhatA = 0, new_xhatB = 0;
//
//    float xhatA = xhatA_P1;
//    float xhatB = xhatB_P1;
//
//    float xA = (xA_P1/P1_XA_factor)-P1_XA_offset;
//    float u = u1_P1;
//
//
//    new_xhatA = aAA*xhatA + aAB*xhatB + u*bA + LAA*(xA-xhatA);
//    new_xhatB = aBA*xhatA + aBB*xhatB + u*bB + LBA*(xA-xhatA);
//
//    xhatA_P1 = new_xhatA;
//    xhatB_P1 = new_xhatB;
//
//    u = (KAA*new_xhatA + KAB*new_xhatB);
//
//    u1_P1 = u;
//
//    txData2[0] = ((u1_P1 + C1_U1_offset)*C1_U1_factor);
//    txData2[1] = 0;
//
//    /* Initialize the message structure */
//    IfxCan_Message txMsg;
//    IfxCan_Can_initMessage(&txMsg);
//    txMsg.messageId = 0x517;
//    txMsg.bufferNumber = 4;
//    //printf("calculated data\n");
//    /*Transmit Data*/
//    while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData2) == IfxCan_Status_notSentBusy)
//    printf("task 1 successfully completed\n");
// }
int gcd(int a, int b){

    if (b == 0)
        return a;
    else
        return gcd(b ,a%b);
}

int lcm(int a, int b){
    return a*b/gcd(a,b);
}

int hp(){
    printf("hyperperiod calc= %d\n",HP);
    int a = esp_h_set[task_per[0]];
    int b = ttc_h_set[task_per[1]];
    int H = lcm(a, b);
//    a = cc_h_set[task_per[2]];
//    b = sc_h_set[task_per[3]];
//    H = lcm(H, a);
//    H = lcm(H, b);
    ct_esp = HP / esp_h_set[task_per[0]];
    int j = ct_esp;
//    for (int j = 0; j++; j < ct_esp ){
    while (j--> 0){
//    printf("css for = %d-th instance of the task 0\n",j);
        int per = esp_h_set[task_per[0]];
        css_esp[j] = 1;//esp_states[per][k];
    }
    ct_ttc = HP / ttc_h_set[task_per[1]];
//    for (int j = 0; j++; j < ct_ttc ){
    j = ct_ttc;
    while (j--> 0){
//        printf("css for = %d-th instance of the task 1\n",j);
        int per = ttc_h_set[task_per[1]];
        css_ttc[j] = 1;//esp_states[per][k];
    }
//    ct_cc = HP / cc_h_set[task_per[2]];
//    j = ct_cc;
////    for (int j = 0; j++; j < ct_cc ){
//    while (j--> 0){
////        printf("css for = %d-th instance of the  task 2\n",j);
//        int per = cc_h_set[task_per[2]];
//        css_cc[j] = 1;//esp_states[per][k];
//    }
//    ct_sc = HP / sc_h_set[task_per[3]];
//    j = ct_sc;
////    for (int j = 0; j++; j < ct_sc ){
//    while (j--> 0){
////        printf("css for = %d-th instance of the task 3\n",j);
//        int per = sc_h_set[task_per[3]];
//        css_sc[j] = 1;//esp_states[per][k];
//    }
    return H;
}

/*------------------------ EBCM -ECU1 ---------------------------------*/

//void t10_tx()/* h = 10ms EBCM*/
//{
//    i=i+10;
//
//    uint32 txData1[2];
//
//    uint32 txData2[2];
//
//    uint32 txData3[2];
//
//
//    IfxCan_Message txMsg1;
//    IfxCan_Can_initMessage(&txMsg1);
//    txMsg1.messageId = 0xC5;
//    txMsg1.bufferNumber = 1;
//
//
//    IfxCan_Message txMsg2;
//    IfxCan_Can_initMessage(&txMsg2);
//    txMsg2.messageId = 0xC1;
//    txMsg2.bufferNumber = 2;
//
//    IfxCan_Message txMsg3;
//    IfxCan_Can_initMessage(&txMsg3);
//    txMsg3.messageId = 0x1E5;
//    txMsg3.bufferNumber = 3;
//
//
//    txData1[0] = 100+i;
//    txData1[1] = 0;
//
//    txData2[0] = 200+i;
//    txData2[1] = 0;
//
//    txData3[0] = CAN1_ECR0.B.TEC;
//    txData3[1] = 0;
//
//
//    /*Transmit Data*/
//
//    while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);
//
//    while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg2, txData2) == IfxCan_Status_notSentBusy);
//
//    while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg3, txData3) == IfxCan_Status_notSentBusy);
//
////    printf("task 10ms successfully completed\n");
//}
/*------------------------ tx tasks ---------------------------------*/
void t10_tx()/* h = 10ms*/
{
    int i = 0;
//    printf("task with per = 10ms tx started\n");

    while(i < 4){//for (int i = 0; i++; i < task_ct){

       if (i == 0 && esp_h_set[task_per[i]]==10){

           if (sensed_esp){
               CanBasicDemo_run_esp();
               sensed_esp = 0;
           }
           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
//           printf("%d th task with per = 10ms successfully completed\n",i);

       }else if (i == 1 && ttc_h_set[task_per[i]]==10){
           if (sensed_ttc){
               CanBasicDemo_run_ttc();
               sensed_ttc = 0;
           }
           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
//           printf("%d th task with per = 10ms successfully completed\n",i);

       }else if (i == 2 && cc_h_set[task_per[i]]==10){

           if (sensed_cc){
               CanBasicDemo_run_cc();
               sensed_cc = 0;
           }
           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
//           printf("%d th task with per = 10ms successfully completed\n",i);

       }else if (i == 3 && sc_h_set[task_per[i]]==10){

           if (sensed_sc){
               CanBasicDemo_run_sc();
               sensed_sc = 0;
           }
           while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
//           printf("%d th task with per = 10ms successfully completed\n",i);

       }else {



       }
//       IfxCan_Message txMsg1;
//       uint32 txData1[2];
//       IfxCan_Can_initMessage(&txMsg1);
//       txMsg1.messageId = esp_tx_id;
//       txMsg1.bufferNumber = esp_tx_buf;
//       while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);
//       printf("tx id %x\n",txMsg1.messageId);
       i++;
   }
}

void t20_tx()/* h = 20ms */
{
    int i = 0;
//    printf("task with per = 20ms tx started\n");
    while(i< task_ct){//for (int i = 0; i++; i < task_ct){

//        printf("20ms task %d\n",i);

        if (i == 0 && esp_h_set[task_per[i]]==20){

            if (sensed_esp){
            CanBasicDemo_run_esp();
            sensed_esp = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
            printf("%d th task with per = 20ms successfully completed\n",i);

        }else if (i == 1 && ttc_h_set[task_per[i]]==20){

            if (sensed_ttc){
                CanBasicDemo_run_ttc();
                sensed_ttc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 20ms successfully completed\n",i);

        }else if (i == 2 && cc_h_set[task_per[i]]==20){

            if (sensed_cc){
                CanBasicDemo_run_cc();
                sensed_cc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
            printf("%d th task with per = 20ms successfully completed\n",i);

        }else if (i == 3 && sc_h_set[task_per[i]]==20){

            if (sensed_sc){
                CanBasicDemo_run_sc();
                sensed_sc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 20ms successfully completed\n",i);

        }else {


        }
        i++;
    }
//    printf("task 20ms successfully completed\n");
}

void t40_tx()/* h = 40ms */
{
    int i = task_ct;
    printf("task with per = 40ms tx started\n");
    while(i-->=0){//for (int i = 0; i++; i < task_ct){

//        printf("40ms task %d\n",i);

        if (i == 0 && esp_h_set[task_per[i]]==410){

            if (sensed_esp){
            CanBasicDemo_run_esp();
            sensed_esp = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 40ms successfully completed\n",i);

        }else if (i == 1 && ttc_h_set[task_per[i]]==40){

            if (sensed_ttc){
                CanBasicDemo_run_ttc();
                sensed_ttc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 40ms successfully completed\n",i);

        }else if (i == 2 && cc_h_set[task_per[i]]==40){

            if (sensed_cc){
                CanBasicDemo_run_cc();
                sensed_cc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 40ms successfully completed\n",i);

        }else if (i == 3 && sc_h_set[task_per[i]]==40){

            if (sensed_sc){
                CanBasicDemo_run_sc();
                sensed_sc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 40ms successfully completed\n",i);

        }else {



        }
    }
//    printf("task 40ms successfully completed\n");
}

void t50_tx()/* h = 50ms */
{
    int i = task_ct;
    printf("task with per = 50ms tx started\n");
    while(i-->=0){//for (int i = 0; i++; i < task_ct){

//        printf("50ms task %d\n",i);

        if (i == 0 && esp_h_set[task_per[i]]==50){

            if (sensed_esp){
            CanBasicDemo_run_esp();
            sensed_esp = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 50ms successfully completed\n",i);

        }else if (i == 1 && ttc_h_set[task_per[i]]==50){

            if (sensed_ttc){
                CanBasicDemo_run_ttc();
                sensed_ttc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
            printf("%d th task with per = 50ms successfully completed\n",i);

        }else if (i == 2 && cc_h_set[task_per[i]]==50){

            if (sensed_cc){
                CanBasicDemo_run_cc();
                sensed_cc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 50ms successfully completed\n",i);

        }else if (i == 3 && sc_h_set[task_per[i]]==50){

            if (sensed_sc){
                CanBasicDemo_run_sc();
                sensed_sc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 50ms successfully completed\n",i);

        }else {


        }
    }
//    printf("task 50ms successfully completed\n");
}

void t80_tx()/* h = 80ms */
{
    int i = task_ct;
//    printf("task with per = 80ms tx started\n");
    while(i-->=0){//for (int i = 0; i++; i < task_ct){

//        printf("80ms task %d\n",i);

        if (i == 0 && esp_h_set[task_per[i]]==80){

            if (sensed_esp){
            CanBasicDemo_run_esp();
            sensed_esp = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 80ms successfully completed\n",i);

        }else if (i == 1 && ttc_h_set[task_per[i]]==80){

            if (sensed_ttc){
                CanBasicDemo_run_ttc();
                sensed_ttc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 80ms successfully completed\n",i);

        }else if (i == 2 && cc_h_set[task_per[i]]==80){

            if (sensed_cc){
                CanBasicDemo_run_cc();
                sensed_cc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 80ms successfully completed\n",i);

        }else if (i == 3 && sc_h_set[task_per[i]]==80){

            if (sensed_sc){
                CanBasicDemo_run_sc();
                sensed_sc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
            printf("%d th task with per = 80ms successfully completed\n",i);

        }else {



        }
    }
//    printf("task 80ms successfully completed\n");
}

void t100_tx()/* h = 100ms */
{
    int i = task_ct;
//    printf("task with per = 100ms tx started\n");
    while(i-->=0){//for (int i = 0; i++; i < task_ct){

//        printf("100ms task %d\n",i);

        if (i == 0 && esp_h_set[task_per[i]]==10){

            if (sensed_esp){
            CanBasicDemo_run_esp();
            sensed_esp = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 100ms successfully completed\n",i);

        }else if (i == 1 && ttc_h_set[task_per[i]]==100){

            if (sensed_ttc){
                CanBasicDemo_run_ttc();
                sensed_ttc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 100ms successfully completed\n",i);

        }else if (i == 2 && cc_h_set[task_per[i]]==100){

            if (sensed_cc){
                CanBasicDemo_run_cc();
                sensed_cc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 100ms successfully completed\n",i);

        }else if (i == 3 && sc_h_set[task_per[i]]==100){

            if (sensed_sc){
                CanBasicDemo_run_sc();
                sensed_sc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 100ms successfully completed\n",i);

        }else {



        }
    }
//    printf("task 100ms successfully completed\n");
}

void t120_tx()/* h = 120ms */
{
    int i = task_ct;
//    printf("task with per = 120ms tx started\n");
    while(i-->=0){//for (int i = 0; i++; i < task_ct){

//        printf("120ms task %d\n",i);

        if (i == 0 && esp_h_set[task_per[i]]==120){

            if (sensed_esp){
            CanBasicDemo_run_esp();
            sensed_esp = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txEsp, txDataEsp) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 120ms successfully tx\n",i);

        }else if (i == 1 && ttc_h_set[task_per[i]]==120){

            if (sensed_ttc){
                CanBasicDemo_run_ttc();
                sensed_ttc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txTtc, txDataTtc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 120ms successfully tx\n",i);

        }else if (i == 2 && cc_h_set[task_per[i]]==120){

            if (sensed_cc){
                CanBasicDemo_run_cc();
                sensed_cc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txCc, txDataCc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 120ms successfully tx\n",i);

        }else if (i == 3 && sc_h_set[task_per[i]]==120){

            if (sensed_sc){
                CanBasicDemo_run_sc();
                sensed_sc = 0;
            }
            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txSc, txDataSc) == IfxCan_Status_notSentBusy);
//            printf("%d th task with per = 120ms successfully tx\n",i);

        }else {


        }
    }
//    printf("task 120ms successfully completed\n");
}

void t7_busload(int a)
{
    //core_0_online=1;


    uint32 ID[5]= {0x230,0x323,0x90,0x98,0x500};


    uint32 txData1[2];
    uint32 txData2[2];
    uint32 txData3[2];
    uint32 txData4[2];
    uint32 txData5[2];

    IfxCan_Message txMsg1;
    IfxCan_Can_initMessage(&txMsg1);
    txMsg1.messageId = ID[0];
    txMsg1.bufferNumber = 13;


    IfxCan_Message txMsg2;
       IfxCan_Can_initMessage(&txMsg2);
       txMsg2.messageId = ID[1];
       txMsg2.bufferNumber = 14;


       IfxCan_Message txMsg3;
          IfxCan_Can_initMessage(&txMsg3);
          txMsg3.messageId = ID[2];
          txMsg3.bufferNumber = 15;



          IfxCan_Message txMsg4;
             IfxCan_Can_initMessage(&txMsg4);
             txMsg4.messageId = ID[3];
             txMsg4.bufferNumber = 16;


             IfxCan_Message txMsg5;
             IfxCan_Can_initMessage(&txMsg5);
             txMsg5.messageId = ID[4];
             txMsg5.bufferNumber = 17;



             txData1[0] = txData2[0]= txData3[0]=txData4[0]=txData5[0]= 100+i;
             txData1[1] = txData2[1] = txData3[1] = txData4[1] = txData5[1] = 0;

             if (a == 1)
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);
             else if(a == 2)
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg2, txData2) == IfxCan_Status_notSentBusy);
             else if(a == 3)
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg3, txData3) == IfxCan_Status_notSentBusy);
             else if(a == 4)
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg4, txData4) == IfxCan_Status_notSentBusy);
             else if(a == 5)
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg5, txData5) == IfxCan_Status_notSentBusy);
             else {
                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg1, txData1) == IfxCan_Status_notSentBusy);

                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg2, txData2) == IfxCan_Status_notSentBusy);

                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg3, txData3) == IfxCan_Status_notSentBusy);

                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg4, txData4) == IfxCan_Status_notSentBusy);

                 while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg5, txData5) == IfxCan_Status_notSentBusy);
             }



    printf("task 700 successfully completed\n");
}

/* Macro to define the Interrupt Service Routine. */
IFX_INTERRUPT(interruptGtmTom, 0, ISR_PRIORITY_TOM);
/* transmission strategy for non-preemptive schedule */

int slot_id = 0;

/* Interrupt Service Routine of the TOM */
void interruptGtmTom(void)
{
    /* hns test */
    /*
    if(allinst == 10){
        core_1_online = 1;
        allinst = 0;
//        inst = 0;
    }
    */

    /* transmission strategy for non-preemptive schedule */
    /*
    int last = task_sequence4[slot_id];
    int next = task_sequence4[slot_id+1];

    if (slot_id==599)
    {
        next = 0;
    }

    if (slot_id==600)
    {
        slot_id=0;
        tx = 0;
    }

//    CanBasicDemo_run2(void);

    int tx = ((last - next) != 0)? 1: 0;
    task_scheduler(task_sequence4[slot_id],tx,ex);
    */
//    if (slot_id==600)
//    clock_t now = clock();
//    unsigned long dur1 = (now-last);
//    last = now;
//    printf("At %d clock pulse spent  %ld \n", i,dur1);
    BO_ISR();
    i = i+1;

    if (slot_id % 2 == 0)//0.003--100freq,clk1
    {
//        t20_tx();

//            t7_busload();
    }
    if (slot_id % 4 == 0)//0.01--100freq,clk1
    {
//        wait(g_tickFor3ms);
//        wait(g_tickFor3ms);
//        t12_5_tx();//---
        t10_tx();
//        t7_busload(1);
    }
    if (slot_id % 10 == 0)//0.02--100freq,clk1
    {
            t20_tx();
//            t3_transmission();
    }
//    if (slot_id % 6 == 0)/* < 0.025 */
//    {
//        if (sensed_esp){
//            CanBasicDemo_run_esp();
//            sensed_esp = 0;
//        }
//    }
//    if (slot_id % 7 == 0)/* ~ 0.025 *///tom 1
//    {
////        t25_tx();//---
//    }
    if (slot_id % 13 == 0)//0.04--100freq,clk1
    {
            t40_tx();
//            t3_transmission();
//            t7_busload(2);
    }
    if (slot_id % 15 == 0)//0.05--100freq,clk1
    {
//        t2_brakes();//task_scheduler(200);/* brakes */
//        t4_ttc();//task_scheduler(100);/* ttc */
        t50_tx();
        t80_tx();
//        t50_tx2();//---
    }
    if (slot_id % 30 == 0){//0.08--100freq,clk1

//        t80_tx();
//        printf("80 ms task\n");
    }
    if (slot_id % 40 == 0){/* 0.1 */
//            task_scheduler(200);/* brakes */
//            task_scheduler(100);/* ttc */
        t100_tx();
//        printf("hp = %d\n",hp());
//        t7_busload(3);
    }
    if (slot_id % 50 == 0){/* 0.12 */

        t120_tx();
//        t7_busload(4);
//        printf("120 ms task\n");
    }
    if (slot_id % 75 == 0){/* 0.25 */
//            task_scheduler(200);/* brakes */
//            task_scheduler(100);/* ttc */
//        t250_tx();//----

    }
    if (slot_id % 160 == 0){/* 0.5 */
//            task_scheduler(200);/* brakes */
//            task_scheduler(100);/* ttc */
//        t500_tx();//----
    }
    if (slot_id % 303 == 0){/* 1 */
//            task_scheduler(200);/* brakes */
//            task_scheduler(100);/* ttc */
//        t1000_tx();
//        t1000_tx2();//----
//        t7_busload(5);
    }
//    if (slot_id % 24 == 0){/* 0.08 */
//        task_scheduler(200);/* brakes */
//        task_scheduler(100);/* ttc */
//    }
    slot_id=slot_id+1;
    /* reset at hyper period */
    slot_id=slot_id+1;
    if (slot_id % 7 == 0){/* 0.02 *///
        if(HP==20){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
            slot_id = 1;
//            HP =hp();
        }
    }else if (slot_id % 13 == 0){/* 0.04 *///
        if(HP==40){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
            slot_id = 1;
//            HP = hp();
        }
    }else if (slot_id % 15 == 0)/* 0.05*/
    {
        if(HP==50){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
//           HP =hp();
       }

    }else if (slot_id % 27 == 0){/* 0.08 */
        if(HP==80){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
//           HP =hp();
       }
    }else if (slot_id % 30 == 0){/* 0.1 */
        if(HP==100){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
//           HP =hp();
       }
    }else if (slot_id % 40 == 0){/* 0.12 */
        if(HP==120){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
//           HP =hp();
       }

    }else if (slot_id % 66 == 0){/* 0.2 */
        if(HP==200){
            printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
//           HP =hp();
       }
    }else if (slot_id % 120 == 0){/* 0.4 */
        if(HP==400){
           printf("here at slot = %d HP = %d\n",slot_id,HP);
           slot_id = 1;
           hp();
       }
    }
    if (slot_id % 303 == 0){/* 1 */
        printf("resetting slot_id=%d at i=%d",slot_id,i);
        slot_id=0;
        HP = hp();
//        task_scheduler(200);
    }
//    if (slot_id % 290){/* 1s */
//        t1000_tx();
//        slot_id=0;
//    }
//    printf("clock at i=\n",i);
//    if(done == 1){
//        printf("done still one\n");
//        i = i+1;
//    }else if(done == 0){
//        i= 0;
//    }
//    task_scheduler(task_sequence4[slot_id]);
//    IfxAsclin_Asc_isrTransmit(&g_asc);

    /* control tasks */
//    if (sensed_ttc){
//        CanBasicDemo_run_ttc();
//        sensed_ttc = 0;
//    }
//    if (sensed_esp){
//        CanBasicDemo_run_esp();
//        sensed_esp = 0;
//    }
    IfxGtm_Tom_Timer_acknowledgeTimerIrq (&g_timerDriver);  /* Clear the timer event */
}

/* This function initializes the TOM */
void initGtmTom(void)
{
    IfxGtm_enable(&MODULE_GTM); /* Enable GTM */
    g_tickFor3ms = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME);
    /* TOM */
    IfxGtm_Tom_Timer_Config timerConfig;                                        /* Timer configuration              */
    IfxGtm_Tom_Timer_initConfig(&timerConfig, &MODULE_GTM);                     /* Initialize timer configuration   */

    timerConfig.base.frequency       = TOM_FREQ;                                /* Set timer frequency              */
    timerConfig.base.isrPriority     = ISR_PRIORITY_TOM;                        /* Set interrupt priority           */
    timerConfig.base.isrProvider     = IfxSrc_Tos_cpu0;                         /* Set interrupt provider           */
    timerConfig.tom                  = IfxGtm_Tom_1;                            /* Define the timer used            */
    timerConfig.timerChannel         = IfxGtm_Tom_Ch_0;                         /* Define the channel used          */
    timerConfig.clock                = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk1;          /* Define the CMU clock used        */

    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);               /* Enable the CMU clock             */
    IfxGtm_Tom_Timer_init(&g_timerDriver, &timerConfig);                        /* Initialize the TOM               */

    //IfxPort_setPinModeOutput(LED1, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);  /* Set pin mode         */
    //IfxPort_setPinModeOutput(LED2, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    IfxGtm_Tom_Timer_run(&g_timerDriver);                                       /* Start the TOM                    */
    last = clock();
//        txDataEsp[1] = esp_h_set[task_per[0]] ;
//        txDataEsp[0] = 0x00 ;
//        txDataTtc[1] = ttc_h_set[task_per[1]] ;
//        txDataTtc[0] = 0x00 ;
    //    txDataCc[1] = cc_h_set[task_per[2]] ;
    //    txDataCc[0] = 0x00 ;
    //    txDataSc[1] = sc_h_set[task_per[3]] ;
    //    txDataSc[0] = 0x00 ;
//    HP=hp();
}
/*******************************************************
///* Macro to define the Interrupt Service Routine. */
//IFX_INTERRUPT(interruptGtmTom1, 0, ISR_PRIORITY_TOM1);
//
//int slot_id_1 = 0;
//
///* Interrupt Service Routine of the TOM_1 */
//void interruptGtmTom1(void)
//{
////    BO_ISR();
////    i = i+1;
//
//    if (slot_id_1 % 2 == 0)/* 0.0125 */
//    {
//            t12_5_tx();
//    }
//    if (slot_id % 4 == 0)/* 0.025 *///tom 1
//    {
//        t25_tx();
//    }
//    slot_id_1 = slot_id_1+1;
//    if (slot_id_1 == 8){
//        slot_id_1=0;
//    }
//    IfxGtm_Tom_Timer_acknowledgeTimerIrq (&g_timerDriver1);  /* Clear the timer event */
//}
//
///* This function initializes the TOM */
//void initGtmTom1(void)
//{
//    IfxGtm_enable(&MODULE_GTM); /* Enable GTM */
//    g_tickFor3ms = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME);
//    /* TOM 1 */
//    IfxGtm_Tom_Timer_Config timerConfig1;                                       /* Timer configuration              */
//    IfxGtm_Tom_Timer_initConfig(&timerConfig1, &MODULE_GTM);                    /* Initialize timer configuration   */
//
//    timerConfig1.base.frequency       = TOM_FREQ_1;                             /* Set timer frequency              */
//    timerConfig1.base.isrPriority     = ISR_PRIORITY_TOM1;                      /* Set interrupt priority           */
//    timerConfig1.base.isrProvider     = IfxSrc_Tos_cpu0;                        /* Set interrupt provider           */
//    timerConfig1.tom                  = IfxGtm_Tom_1;                           /* Define the timer used            */
//    timerConfig1.timerChannel         = IfxGtm_Tom_Ch_0;                        /* Define the channel used          */
//    timerConfig1.clock                = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk1;         /* Define the CMU clock used        */
//
//    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);               /* Enable the CMU clock             */
//    IfxGtm_Tom_Timer_init(&g_timerDriver1, &timerConfig1);                      /* Initialize the TOM               */
//
//    //IfxPort_setPinModeOutput(LED1, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);  /* Set pin mode         */
//    //IfxPort_setPinModeOutput(LED2, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
//
//    IfxGtm_Tom_Timer_run(&g_timerDriver1);                                       /* Start the TOM_1                    */
//    last = clock();
//}
//*****************************************************************/
/* interrupt to raise when bus-off*/
//IFX_INTERRUPT(BO_ISR, 0, ISR_PRIORITY_CAN1_BO);
//
void BO_ISR(void)
{
    Ifx_CAN   *canSfr =  &MODULE_CAN1;
    Ifx_CAN_N* node = IfxCan_getNodePointer(canSfr,(IfxCan_NodeId)0);
    boolean isbusoff = IfxCan_Node_getBusOffStatus(node);//CAN0_PSR0.B.BO;
    boolean warning = IfxCan_Node_getWarningStatus(node);//CAN0_PSR0.B.EW;
//    IfxCan_Status status;
    /* rx reset msg */
    /*
    uint32 txData[2];
    IfxCan_Message txMsg;
    IfxCan_Can_initMessage(&txMsg);
    txMsg.messageId = sba_dtc_tx_id;
    txMsg.bufferNumber = sba_dtc_tx_buf;//2;
    txMsg.dataLengthCode = IfxCan_DataLengthCode_8;
    txData[0] = node->ECR.B.CEL;//node->ECR.B.TEC; //CAN1_ECR0.B.TEC;
    txData[1] = 0;
    */
    if (warning){
//        printf("TEC: %u, busoff status : %d, and detection count : %d at %d\n",CAN1_ECR0.B.TEC, isbusoff, sba_ct, i);
        printf("TEC: %u, busoff status : %d, and detection count : %d at %d\n",node->ECR.B.TEC, isbusoff, sba_ct, i);
//        while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData) == IfxCan_Status_notSentBusy);
    }
    if(isbusoff)
    {
        IfxCan_Node_clearInterruptFlag(node,IfxCan_Interrupt_busOffStatus);
        node->CCCR.B.INIT = 0; // clearing to reinit
        printf("reset from busoff\n");
    }
}

void CanBasicDemo_init(void)
{
    IfxScuCcu_Config IfxScuCcuConfig;

    /* interrupt groups configuration */
    volatile Ifx_SRC_SRCR *srcPointer;
    /* disable interrupts */
    boolean  interruptState = IfxCpu_disableInterrupts();

    /* Default clock initialisation */
    IfxScuCcu_initConfig(&IfxScuCcuConfig);
    IfxScuCcu_init(&IfxScuCcuConfig);

    /* CAN0 initilisation */
    {
        /* create module configuration */
        IfxCan_Can_Config canConfig;
        IfxCan_Can_initModuleConfig(&canConfig, &MODULE_CAN0);

        /* initialize module */
        IfxCan_Can_initModule(&g_CanBasic.drivers.can[0], &canConfig);
    }

    /* CAN1 initilisation */
    {
         /*create module configuration*/
        IfxCan_Can_Config canConfig;
        IfxCan_Can_initModuleConfig(&canConfig, &MODULE_CAN1);

         /*initialize module*/
        IfxCan_Can_initModule(&g_CanBasic.drivers.can[1], &canConfig);
    }

     /*create node configuration*/

     /*CAN 0 Node0 as receive node*/
    {
        IfxCan_Can_NodeConfig nodeConfig;
        IfxCan_Can_initNodeConfig(&nodeConfig, &g_CanBasic.drivers.can[0]);
        /* for busoff */
        nodeConfig.baudRate.baudrate = 500000;//250000;


        nodeConfig.nodeId = IfxCan_NodeId_0;
        nodeConfig.frame.type = IfxCan_FrameType_receive;

        nodeConfig.messageRAM.standardFilterListStartAddress = 0x100;
        nodeConfig.messageRAM.rxBuffersStartAddress          = 0x200;
        nodeConfig.messageRAM.rxFifo0StartAddress            = 0x300;
        nodeConfig.messageRAM.baseAddress                    = (uint32)&MODULE_CAN0;

        nodeConfig.rxConfig.rxMode                           = IfxCan_RxMode_sharedAll;

        nodeConfig.rxConfig.rxFifo0Size                      = 8;
        nodeConfig.rxConfig.rxFifo0OperatingMode             = IfxCan_RxFifoMode_overwrite;

        IfxCan_Can_Pins pins;
        pins.rxPin = &IfxCan_RXD00B_P20_7_IN;
        pins.rxPinMode = IfxPort_InputMode_pullUp;
        pins.txPin = &IfxCan_TXD00_P20_8_OUT;
        pins.txPinMode = IfxPort_OutputMode_pushPull;
        pins.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
        nodeConfig.pins = &pins;

        /* For interrupt configuration user needs to configure the priority and select one of the 16 interrupt lines*/
//        nodeConfig.interruptConfig.reint.priority = ISR_PRIORITY_CAN0_RX ;
//        nodeConfig.interruptConfig.reint.interruptLine =  IfxCan_InterruptLine_14;
//        nodeConfig.interruptConfig.reint.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

//        Interrupt configuration for Fifo 0
        nodeConfig.interruptConfig.rxf0n.priority = ISR_PRIORITY_CAN0_RX ;
        nodeConfig.interruptConfig.rxf0n.interruptLine =  IfxCan_InterruptLine_14;
        nodeConfig.interruptConfig.rxf0n.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

        IfxCan_Can_initNode(&g_CanBasic.drivers.canNode[0], &nodeConfig);

        Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(g_CanBasic.drivers.canNode[0].can, nodeConfig.nodeId);

        IfxCan_Node_enableConfigurationChange(nodeSfr);
        /* Enable interrupts in CAN */
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_rxFifo0NewMessage);
        IfxCan_Node_disableConfigurationChange(nodeSfr);
        printf(" Rx Node Base Address  = %x\n",(unsigned int)g_CanBasic.drivers.canNode[0].node);
    }

    /* CAN 1 Node 0 as transmit node*/
    {
        IfxCan_Can_NodeConfig nodeConfig;
        IfxCan_Can_initNodeConfig(&nodeConfig, &g_CanBasic.drivers.can[1]);

        /* for busoff */
        nodeConfig.baudRate.baudrate = 500000;//250000;
        nodeConfig.interruptConfig.busOffStatusEnabled=1;
        nodeConfig.interruptConfig.boff.priority = ISR_PRIORITY_CAN1_BO;
        nodeConfig.interruptConfig.boff.interruptLine = IfxCan_InterruptLine_13;
        nodeConfig.interruptConfig.boff.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());


        //added
        nodeConfig.interruptConfig.protocolErrorArbitrationEnabled=1;
        nodeConfig.interruptConfig.watchdogEnabled=1;
        nodeConfig.interruptConfig.protocolErrorDataEnabled=1;
        //end


        nodeConfig.nodeId = IfxCan_NodeId_0;
        nodeConfig.frame.type = IfxCan_FrameType_transmit;
        nodeConfig.txConfig.dedicatedTxBuffersNumber = 20;

        nodeConfig.messageRAM.txBuffersStartAddress = 0x400;
        nodeConfig.messageRAM.baseAddress           = (uint32)&MODULE_CAN1;

        IfxCan_Can_Pins pins;
        pins.rxPin = &IfxCan_RXD10C_P23_0_IN;
        pins.rxPinMode = IfxPort_InputMode_pullUp;
        pins.txPin = &IfxCan_TXD10_P23_1_OUT;
        pins.txPinMode = IfxPort_OutputMode_pushPull;
        pins.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
        nodeConfig.pins = &pins;

         /*Enabling interrupts*/
        nodeConfig.interruptConfig.traco.priority  = ISR_PRIORITY_CAN1_TX ;
        nodeConfig.interruptConfig.traco.interruptLine =  IfxCan_InterruptLine_15;
        nodeConfig.interruptConfig.traco.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

         /*initialize module*/
        IfxCan_Can_initNode(&g_CanBasic.drivers.canNode[1], &nodeConfig);

        Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(g_CanBasic.drivers.canNode[1].can, nodeConfig.nodeId);

        IfxCan_Node_enableConfigurationChange(nodeSfr);

        /* Enable interrupts in CAN */
    IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_transmissionCompleted);

    /* disable configuration change CCCR.CCE = 0 */
    IfxCan_Node_disableConfigurationChange(nodeSfr);

        printf(" Tx Node Base Address  = %x\n",(unsigned int)g_CanBasic.drivers.canNode[1].node);
    }

    /* set filters */

    {
        /* Initialise the filter structure */
        IfxCan_Filter filter;

        /* Set a range filter to accept the CAN message with Ids 0x00- 0x7ff*/

        /* set filter0 for rxBuffer 0 */
        filter.number = 0;
        filter.elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxBuffer;
        filter.id1 = 0x00;
        filter.rxBufferOffset = IfxCan_RxBufferId_0;

        IfxCan_Can_setStandardFilter(&g_CanBasic.drivers.canNode[0], &filter);

        /* set filter0 for rxBuffer 1 */
        filter.number = 1;
        filter.elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxBuffer;
        filter.id1 = 0x7FF;
        filter.rxBufferOffset = IfxCan_RxBufferId_1;

        IfxCan_Can_setStandardFilter(&g_CanBasic.drivers.canNode[0], &filter);
    }

    /* enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);

    printf("CAN is initialized\n");
//    HP = hp();
}

void CanBasicDemo_run_esp(void) /*    This is the code of ESP    */
{
    uint32 txData1[2];
    done = 1;
//    printf("starting to calculate esp at i=%d\n",i);
/*  electronic stability program code   */
    float aAA = 0.54450, aAB = -0.1353;
    float aBA = 0.008, aBB = 0.163;

    float bA = 0.7390;
    float bB = 5.9411;

    float KAA = -0.0013419, KAB = -0.0273664;

    float LAA = -0.067611;
    float LBA = 0.164042;
    /*   for 0.01s sampling period */
        if (esp_h_set[task_per[0]]==10){
        //
        printf("Acquiring system matrices for task esp, periodicity 10\n");
        float aAA = 0.8374, aAB = -0.01989;
        float aBA = 0.5618, aBB =  0.8353;

        float bA = 0.06163;
        float bB = 1.429;

        float KAA = -0.282596525892441, KAB = -0.096029618248812;


        float LAA = 0.052615649974912;
        float LBA = 0.726356915397122;
        }
    /*   for 0.025s sampling period */
    if (esp_h_set[task_per[0]]==20){
//        printf("Acquiring system matrices for task esp, periodicity 20\n");
        /*
        float aAA = 0.54450, aAB = -0.1353;
        float aBA = 0.008, aBB = 0.163;

        float bA = 0.7390;
        float bB = 5.9411;

        float KAA = -0.0013419, KAB = -0.0273664;

        float LAA = -0.067611;
        float LBA = 0.164042;
        */
        //
        float aAA = 0.6901, aAB = -0.03327;
        float aBA = 0.9398, aBB = 0.6866;

        float bA = 0.08484;
        float bB = 2.657;

        float KAA = -0.000587825834722 , KAB = -0.078627377099199;


        float LAA = 0.691549977365034;
        float LBA = 0.910261810891498;
        //
    }
/*   for 0.04s sampling period */
    if (esp_h_set[task_per[0]]==40){
        //
        printf("Acquiring system matrices for task esp, periodicity 40\n");
        float aAA = 0.4450, aAB = -0.0458;
        float aBA = 1.2939, aBB = 0.4402;

        float bA = 0.0550;
        float bB = 4.5607;

        float KAA = -0.104236636572187, KAB = -0.029824912471219;

        float LAA = -0.039000000000000;
        float LBA = 0.433900000000000;
        //
    }
    /* for 0.08s sampling period */
    if (esp_h_set[task_per[0]]==80){
        ///*
        printf("Acquiring system matrices for task esp, periodicity 80\n");
        float aAA = 0.1388, aAB = -0.04054;
        float aBA = 1.145, aBB = 0.1345;

        float bA = -0.1294;
        float bB = 6.639;

        float KAA = -0.172081894469707, KAB = -0.020211675195653;

        float LAA = -0.041063953863906;
        float LBA = 0.000265022096397;
        //*/
    }
/*
    // for 0.1s sampling period
    float aAA = 0.05766, aAB = -0.03245;
    float aBA = 0.9169, aBB = 0.05426;

    float bA = -0.2253;
    float bB = 7.094;

    float KAA = -0.128994247514895, KAB = -0.007633372224364;

    float LAA = -0.033484437035141;
    float LBA = 0.000051223324198;
*/
    float new_xhatA = 0, new_xhatB = 0;
    float xhatA = xhatA_P4;
    float xhatB = xhatB_P4;

    float xA = (xA_P4/(float)ESP_XA_factor)-(float)ESP_XA_offset;
    printf("sensor data = %u op =  %f \n",xA_P4, xA);
    float u = u1_P4;

//    if(css_esp[curIdx_esp % ct_esp]){
        new_xhatA = aAA*xhatA + aAB*xhatB + u*bA + LAA*(xA-xhatB);
        new_xhatB = aBA*xhatA + aBB*xhatB + u*bB + LBA*(xA-xhatB);

        u = (KAA*new_xhatA + KAB*new_xhatB);

        xhatA_P4 = new_xhatA;
        xhatB_P4 = new_xhatB;
        u1_P4 = u;
        txDataEsp[0] = ((u1_P4 + ESP_U1_offset)*ESP_U1_factor);
        txDataEsp[1] = esp_h_set[task_per[0]];
        printf("calculated esp data %f tx data %u for sensor data %f and estimated states [%f; %f]\n", u1_P4, txDataEsp[0], xA, xhatA_P4, xhatB_P4);//stopped for testing
//    }else{
//        printf("not calculating or sending esp data due to 0\n");
//    }
//    txData1[0]= ((u1_P4 + ESP_U1_offset)*ESP_U1_factor*100);
//    txData1[1]=0;
//
//    /* Initialise the message strcture */
//    IfxCan_Message txMsg;
//    IfxCan_Can_initMessage(&txMsg);
//
//    txMsg.messageId = 0x01;
//
//    txMsg.bufferNumber = 0;
//
//     /*Transmit Data*/
//    while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData1) == IfxCan_Status_notSentBusy);
//
//    printf("u = %f\n", u);
//    printf("xA = %f\n", xA);
//    printf("txData1 = %d\n", txData1[0]);
    curIdx_esp = curIdx_esp + 1;
    IfxCan_Can_initMessage(&txEsp);
    txEsp.messageId = esp_tx_id;//0xA1;
    txEsp.bufferNumber = 1;
//    printf("calculation done at i=%d u = %f for x=%f\n",i,u,xA);
    done = 0;
}

void CanBasicDemo_run_ttc(void) /* This is the code of TTC  */
{
//    uint32 txData2[2];
    float aAA = 1, aAB = 0.05;
    float aBA = 0, aBB = 0.1;

    float bA = 0.00125;
    float bB = 0.05;

    float KAA = -12.8013, KAB = -13.7651;
    float LAA = -9.0833;
    float LBA = 4.2456;
/*  Trajectory tracking code  0.1s */
    if (ttc_h_set[task_per[1]]==100){
           printf("Acquiring system matrices for task ttc, periodicity 100\n");
    //
       float aAA = 1, aAB = 0.1;
       float aBA = 0, aBB = 1.0;

       float bA = 0.005;
       float bB = 0.1;

     float KAA = -16.0302, KAB = -5.6622;

//       float KAA = -0.9171, KAB = -1.6356;
       float LAA = 0.8327;
       float LBA = 2.5029;
    //
    }
/*  Trajectory tracking code  0.2s */
/*
       float aAA = 1, aAB = 0.2;
       float aBA = 0, aBB = 1.0;

       float bA = 0.02;
       float bB = 0.2;

       float KAA = -4.5453, KAB = -5.4544;
       float F = 0.9171;
       float r = 10;

       float LAA = 1.4783;
       float LBA = 3.2978;
*/
/*  Trajectory tracking code  0.08s */
       else if (ttc_h_set[task_per[1]]==80){
    ///*
           printf("Acquiring system matrices for task ttc, periodicity 80\n");
       float aAA = 1, aAB = 0.08;
       float aBA = 0, aBB = 1.0;

       float bA = 0.0032;
       float bB = 0.08;

//       float KAA = -16.0302, KAB = -5.6622;

       float KAA = -0.9331, KAB = -1.6543;
       float LAA = 0.8327;
       float LBA = 2.5029;
       //*/
       }
    /*  ACC/TTC code  0.05s */
       else if (ttc_h_set[task_per[1]]==50){
        ///*
           printf("Acquiring system matrices for task ttc, periodicity 50\n");
           float aAA = 1, aAB = 0.05;
           float aBA = 0, aBB = 0.1;

           float bA = 0.00125;
           float bB = 0.05;

           float KAA = -12.8013, KAB = -13.7651;
           float LAA = -9.0833;
           float LBA = 4.2456;
        //*/
       }

//       float check = xA - xhatA;

          float new_xhatA = 0, new_xhatB = 0;
          float xhatA = xhatA_P5;
          float xhatB = xhatB_P5;

          float xA = (xA_P5/(float)TTC_XA_factor)-(float)TTC_XA_offset;
          printf("sensor data = %u op =  %f \n",xA_P5, xA);
//          float xB = (xB_P5/(float)TTC_XB_factor)-TTC_XB_offset;
          float u = u1_P5;
          new_xhatA = aAA*xhatA + aAB*xhatB + u*bA + LAA*(xA-xhatA);
          new_xhatB = aBA*xhatA + aBB*xhatB + u*bB + LBA*(xA-xhatA);
//          new_xhatA = aAA*xhatA + aAB*xhatB + u*bA + LAA*(xB-xhatB);
//          new_xhatB = aBA*xhatA + aBB*xhatB + u*bB + LBA*(xB-xhatB);
          xhatA_P5 = new_xhatA;
          xhatB_P5 = new_xhatB;
            u = (KAA*new_xhatA + KAB*new_xhatB);
            //u = (KAA*new_xhatA + KAB*new_xhatB)+F*r;
            u1_P5 = u;
            txDataTtc[0] = ((u1_P5 + TTC_U1_offset)*TTC_U1_factor);
            txDataTtc[1] = ttc_h_set[task_per[1]];
            printf("calculated ttc data %f tx data %u for sensor data %f and estimated states [%f; %f]\n", u1_P5, txDataTtc[0], xA,xhatA_P5, xhatB_P5);//stopped for testing
            /* doing the rest periodically */
//            txData2[0] = ((u1_P5 + TTC_U1_offset)*TTC_U1_factor);
//            txData2[1] = 0;
//
//            /* Initialise the message strcture */
//            IfxCan_Message txMsg;
//            IfxCan_Can_initMessage(&txMsg);
//
//            txMsg.messageId = 0x517;
//            txMsg.bufferNumber = 1;

//            /*Transmit Data*/
//            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData2) == IfxCan_Status_notSentBusy)
//                printf("sent data\n");
            IfxCan_Can_initMessage(&txTtc);
            txTtc.messageId = 0xc4;
            txTtc.bufferNumber = 2;
            curIdx_ttc = curIdx_ttc + 1;
}

void CanBasicDemo_run_cc(void) /* This is the code of CC  */
{
    //    uint32 txData2[2];
    float a[3][3] = {{1, 0.01999, 0.0001996},
                          {-0.001207, 0.9989, 0.0199592},
                          {-0.1206, -0.1066, 0.9942}};

               float b[3][1] = {{3.298e-06}, {0.0004945},  {0.0494}};

               float c[1][3] = {{1,0,0}};

               float d[1][1] = {{0}};

               float K[1][3] = {{-1.31162749341164,   -4.11446896405778,  -3.45485791358866}};

               float L[3][1] = {{1.00759680878837}, {0.858537582674735}, {-0.3684615486981979}};

    //   float KAA = -12.8013, KAB = -13.7651;
    //   float LAA = -9.0833;
    //   float LBA = 4.2456;

    /*  cruise control code  0.02s */
        //
        if (cc_h_set[task_per[2]]==20){
            printf("Acquiring system matrices for task cc, periodicity 20\n");
            float a[3][3] = {{1, 0.01999, 0.0001996},
                      {-0.001207, 0.9989, 0.0199592},
                      {-0.1206, -0.1066, 0.9942}};

           float b[3][1] = {{3.298e-06}, {0.0004945},  {0.0494}};

           float c[1][3] = {{1,0,0}};

           float d[1][1] = {{0}};

           float K[1][3] = {{-1.31162749341164,   -4.11446896405778,  -3.45485791358866}};

           float L[3][1] = {{1.00759680878837}, {0.858537582674735}, {-0.3684615486981979}};


        }else  if (cc_h_set[task_per[2]]==10){/*  cruise control code  0.01s */
            printf("Acquiring system matrices for task cc periodicity 10\n");
           float a[3][3] = {{1,    0.009999,   4.996e-05},
                      {-0.0003021,      0.9997,    0.009987},
                      {-0.0604,    -0.05309,      0.9974}};

           float b[3][1] = {{4.125e-07}, {0.0001237},  {0.02474}};

           float c[1][3] = {{1,0,0}};

           float d[1][1] = {{0}};

           float K[1][3] = {{-1.48980156728307, -4.40324212172318, -3.600226866687}};

           float L[3][1] = {{0.998958860089584}, {0.866745646081839}, {-0.2393745355206229}};
         }else {
             printf("Acquiring system matrices for task cc for wrong periodicity 10\n");
          }
    //       float check = xA - xhatA;

              float new_xhat[3][1]={{0},{0},{0}};
              float xhatA = xhat_CC[0];
              float xhatB = xhat_CC[1];
              float xhatC = xhat_CC[2];


              float y = (y1_CC/(float)CC_XA_factor)-(float)CC_XA_offset;
    //          float xB = (xB_P5/(float)P5_XB_factor)-P5_XB_offset;
              printf("sensor data = %u op =  %f \n",y1_CC, y);
              float u = u1_CC;
              new_xhat[0][0] = a[0][0]*xhatA + a[0][1]*xhatB + a[0][2]*xhatC +  u*b[0][0] + L[0][0]*(y-xhatA);
              new_xhat[1][0] = a[1][0]*xhatA + a[1][1]*xhatB + a[1][2]*xhatC +  u*b[1][0] + L[1][0]*(y-xhatB);
              new_xhat[2][0] = a[2][0]*xhatA + a[2][1]*xhatB + a[2][2]*xhatC +  u*b[2][0] + L[2][0]*(y-xhatC);
//              new_xhat[3][0] = a[3][0]*xhatA + a[3][1]*xhatB + a[3][2]*xhatC + a[3][3]*xhatC + u*b[3] + L[3][0](y-xhatA);

              xhat_CC[0] = new_xhat[0][0];
              xhat_CC[1] = new_xhat[1][0];
              xhat_CC[2] = new_xhat[2][0];
//              xhat_CC[3] = new_xhat[3][0];

              u = (K[0][0]*xhat_CC[0] + K[0][1]*xhat_CC[1] + K[0][2]*xhat_CC[2]);
                //u = (KAA*new_xhatA + KAB*new_xhatB)+F*r;
                u1_CC = u;
                txDataCc[0] = (u1_CC+CC_U1_offset)*CC_U1_factor;
                txDataCc[1] = cc_h_set[task_per[2]];
            printf("calculated cc data %f tx data %u for sensor data %f and estimated states [%f; %f; %f]\n", u1_CC, txDataCc[0], y, xhat_CC[0], xhat_CC[1], xhat_CC[2]);//stopped for testing
            /* doing the rest periodically */
//            txData2[0] = ((u1_P5 + C5_U1_offset)*C5_U1_factor);
//            txData2[1] = 0;
//
//            /* Initialise the message strcture */
//            IfxCan_Message txMsg;
//            IfxCan_Can_initMessage(&txMsg);
//
//            txMsg.messageId = 0x517;
//            txMsg.bufferNumber = 1;

//            /*Transmit Data*/
//            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData2) == IfxCan_Status_notSentBusy)
//                printf("sent data\n");
            curIdx_cc = curIdx_cc + 1;
            IfxCan_Can_initMessage(&txCc);
            txCc.messageId = cc_tx_id;//0x1a1;
            txCc.bufferNumber = cc_tx_buf;//4;

}

void CanBasicDemo_run_sc(void) /* This is the code of SC  */
{
//    uint32 txData2[2];
    float a[4][4] = {{0.9959,   0.03787,  0.002127,  0.001605},
                            {-0.1746,    0.9086,   0.04617,   0.05731},
                            {0.03111,   0.01605,    0.9358,   0.01515},
                            {1.084,    0.5731,    -2.296,   0.09069}};

    float b[4][1] = {{0.03411}, {1.275},  {0.33627}, {-16.97}};

    float c[1][4] = {{1,0,0,0}};

    float d[1][1] = {{0}};

    float K[1][4] = {{-3.69840485205769,  -0.527354601469354, 0.0569469847116363,   -0.0311945072320843}};

    float L[4][1] = {{0.627216669816835}, {0.0776672166534822}, {0.0335031868276192}, {0.804439585315085}};

//       float KAA = -16.0302, KAB = -5.6622;

//       float KAA = -0.9171, KAB = -1.6356;
    float LAA = 0.8327;
    float LBA = 2.5029;

//   float KAA = -12.8013, KAB = -13.7651;
//   float LAA = -9.0833;
//   float LBA = 4.2456;

    //
    if (sc_h_set[task_per[3]]==120){/*  susp control code  0.12s */
        printf("Acquiring system matrices for task sc, periodicity 120\n");
       float a[4][4] = {{0.974436456777446,   0.106064989005852,  -0.001557990365814, 0.006162595428732},
                       {-0.355512277748281,   0.796680317903306,  -0.137495356550256,  0.052946239933692},
                       {0.110630834735291,   0.061625954287317,   0.751616796941050,  0.016633384543772},
                       {0.837663129203259,   0.529462399336920,  -2.168333892705055,  0.000117541463972}};

       float b[4][1] = {{0.150373442163002}, {1.551932432972376},  {0.470420059199107}, {-18.666978407218775}};

       float c[1][4] = {{1,0,0,0}};

       float d[1][1] = {{0}};

       float K[1][4] = {{-2.801543807063152,  -0.505961838498671,   0.076772372763655,  -0.030359278406670}};

       float L[4][1] = {{0.620320155088737}, {-0.138221228206519}, {0.107979746965025}, {0.490620372256037}};

//       float KAA = -16.0302, KAB = -5.6622;

//       float KAA = -0.9171, KAB = -1.6356;
//       float LAA = 0.8327;
//       float LBA = 2.5029;
    }else  if (sc_h_set[task_per[3]]==40){/*  susp control code  0.04s */
        printf("Acquiring system matrices for task sc, periodicity 40\n");
        float a[4][4] = {{0.9959,   0.03787,  0.002127,  0.001605},
                        {-0.1746,    0.9086,   0.04617,   0.05731},
                        {0.03111,   0.01605,    0.9358,   0.01515},
                        {1.084,    0.5731,    -2.296,   0.09069}};

        float b[4][1] = {{0.03411}, {1.275},  {0.33627}, {-16.97}};

        float c[1][4] = {{1,0,0,0}};

        float d[1][1] = {{0}};

        float K[1][4] = {{-3.69840485205769,  -0.527354601469354, 0.0569469847116363,   -0.0311945072320843}};

        float L[4][1] = {{0.627216669816835}, {0.0776672166534822}, {0.0335031868276192}, {0.804439585315085}};

 //       float KAA = -16.0302, KAB = -5.6622;

 //       float KAA = -0.9171, KAB = -1.6356;
        float LAA = 0.8327;
        float LBA = 2.5029;
     }else if (sc_h_set[task_per[3]]==80){/*  susp control code  0.08s */
         printf("Acquiring system matrices for task sc, periodicity 80\n");
         float a[4][4] = {{0.9959,   0.03787,  0.002127,  0.001605},
                         {-0.1746,    0.9086,   0.04617,   0.05731},
                         {0.03111,   0.01605,    0.9358,   0.01515},
                         {1.084,    0.5731,    -2.296,   0.09069}};

         float b[4][1] = {{0.03411}, {1.275},  {0.33627}, {-16.97}};

         float c[1][4] = {{1,0,0,0}};

         float d[1][1] = {{0}};

         float K[1][4] = {{-3.69840485205769,  -0.527354601469354, 0.0569469847116363,   -0.0311945072320843}};

         float L[4][1] = {{0.627216669816835}, {0.0776672166534822}, {0.0335031868276192}, {0.804439585315085}};

      }
    //

//       float check = xA - xhatA;

          float new_xhat[4][1]={{0},{0},{0},{0}};
          float xhatA = xhat_SC[0];
          float xhatB = xhat_SC[1];
          float xhatC = xhat_SC[2];
          float xhatD = xhat_SC[3];

          float y = (y1_SC/(float)SC_XA_factor)-(float)SC_XA_offset;
//          float xB = (xB_P5/(float)P5_XB_factor)-P5_XB_offset;
          printf("sensor data = %u op =  %f \n",y1_SC, y);
          float u = u1_SC;
//          new_xhat[0][0]
                      xhat_SC[0] = a[0][0]*xhatA + a[0][1]*xhatB + a[0][2]*xhatC + a[0][3]*xhatD + u*b[0][0];// + L[0][0]*(y-xhatA);
//          new_xhat[1][0]
                      xhat_SC[1] = a[1][0]*xhatA + a[1][1]*xhatB + a[1][2]*xhatC + a[1][3]*xhatD + u*b[1][0] + L[1][0]*(y-xhatA);
//          new_xhat[2][0]
                      xhat_SC[2] = a[2][0]*xhatA + a[2][1]*xhatB + a[2][2]*xhatC + a[2][3]*xhatD + u*b[2][0] + L[2][0]*(y-xhatA);
//          new_xhat[3][0]
                      xhat_SC[3] = a[3][0]*xhatA + a[3][1]*xhatB + a[3][2]*xhatC + a[3][3]*xhatD + u*b[3][0] + L[3][0]*(y-xhatA);

//          xhat_SC[0] = new_xhat[0][0];
//          xhat_SC[1] = new_xhat[1][0];
//          xhat_SC[2] = new_xhat[2][0];
//          xhat_SC[3] = new_xhat[3][0];

          u = (K[0][0]*xhat_SC[0] + K[0][1]*xhat_SC[1] + K[0][2]*xhat_SC[2] + K[0][3]*xhat_SC[3]);
            //u = (KAA*new_xhatA + KAB*new_xhatB)+F*r;
            u1_SC = u;
            txDataSc[0] = (u1_SC+SC_U1_offset)*SC_U1_factor;
            txDataSc[1] = sc_h_set[task_per[3]];
            printf("calculated sc data %f tx data %u for sensor data %f and estimated states [%f; %f;%f;%f]\n", u1_SC, txDataSc[0], y, xhat_SC[0], xhat_SC[1], xhat_SC[2], xhat_SC[3]);//stopped for testing
            /* doing the rest periodically */
//            txData2[0] = ((u1_P5 + C5_U1_offset)*C5_U1_factor);
//            txData2[1] = 0;
//
//            /* Initialise the message strcture */
//            IfxCan_Message txMsg;
//            IfxCan_Can_initMessage(&txMsg);
//
//            txMsg.messageId = 0x517;
//            txMsg.bufferNumber = 1;

//            /*Transmit Data*/
//            while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData2) == IfxCan_Status_notSentBusy)
//                printf("sent data\n");
            curIdx_sc = curIdx_sc + 1;
            IfxCan_Can_initMessage(&txSc);
            txSc.messageId = sc_tx_id;//0x1a1;
            txSc.bufferNumber = sc_tx_buf;//3;

}

void residue_based_dtc(float a)/* residue based detection for estimators/controllers */
{
    /*Take Modulus of the estimation error value*/

    float mod_check = fabs(a);
    uint32 txData3[2];
    IfxCan_Message txMsg;
    /* Maximum residual value check */
    if ( mod_check >= Th)
    {
      txData3[0] = (mod_check)*100;
      txData3[1] = 0;
    }
    else
    {
       txData3[0] = 0;
       txData3[1] = 0;
    }
    IfxCan_Can_initMessage(&txMsg);

    txMsg.messageId = dtc_tx_id;
    txMsg.bufferNumber = dtc_tx_buf;//2;

    /*Transmit Data*/
    while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData3) == IfxCan_Status_notSentBusy);
}

void sba_dtc(int skipped)/* sba detector */
{
    uint32 txData[2];
    IfxCan_Message txMsg;
    IfxCan_Can_initMessage(&txMsg);
    txMsg.messageId = sba_dtc_tx_id;
    txMsg.bufferNumber = sba_dtc_tx_buf;//2;
    txMsg.dataLengthCode = IfxCan_DataLengthCode_8;
    txData[0] = 0;
    txData[1] = 0;
    if(!skipped)
    {
      sba_ct = sba_ct + 1;
    }
    int ii = 2;
    if (sba_ct >= Th_ct && ii > 0)
    {
      printf("atk attempt > %d at %d \n",sba_ct,i);
      txData[0] = 100;
      txData[1] = 0;
      ii --;
      if(ii==1)
         sba_ct = 0;
    }
    else
    {
       printf("no/1 atk attempt at %d\n",i);
       txData[0] = 0;
       txData[1] = 0;
    }
    /*Transmit Data*/
    while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData) == IfxCan_Status_notSentBusy);
}
